<root>
    <rule>
        <name>Insecure Method Call: unwrap() or expect() without proper error handling</name>
        <regex>(\.unwrap\(\))|(\.expect\(\))</regex>
        <description>Using unwrap() or expect() without proper error handling</description>
    </rule>
    <rule>
        <name>Insecure Type Casting or Creating Uninitialized Memory: transmute() or mem::uninitialized()</name>
        <regex>(\.transmute\(\))|(mem::uninitialized\(\))</regex>
        <description>Using transmute() or mem::uninitialized() to cast between different types or to create uninitialized memory.</description>
    </rule>
    <rule>
        <name>Unsafe Declaration: unsafe keyword or .unsafe_ method calls</name>
        <regex>(\bunsafe\b)|(\.unsafe_)</regex>
        <description>Using unsafe blocks without proper justification or error handling.</description>
    </rule>
    <rule>
        <name>Insecure String Parameter: Using String instead of &str for function parameters</name>
        <regex>fn .*\((.*\bString\b.*)\)</regex>
        <description>Matches function definitions that take a String parameter. Using String instead of &str for function parameters.</description>
    </rule>
        <rule>
        <name>Insecure Method Calls: Using unwrap() or expect() on Option types without proper error handling</name>
        <regex>(\.unwrap\(\))|(\.expect\(\))(\.as_ref\(\))?</regex>
        <description>Matches .unwrap() or .expect() method calls on Option types. Using unwrap() or expect() on Option types without proper error handling:</description>
    </rule>
</root>

